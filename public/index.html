<!--     
    BardBoard - A DiscordJS bot soundboard
    Copyright (C) 2024  Giovanbattista Abbate
  
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.
  
    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.
  
    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>. 
-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üéµ BardBoard & Dragons üêâ</title>
    <link rel="stylesheet" href="/styles.css">
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;600;700&family=Raleway:wght@300;400;500;600&display=swap" rel="stylesheet">
    <script>
        fetch('/env-config')
            .then(response => response.json())
            .then(config => { window.ENV = config; });
    </script>
</head>
<body>

    <!-- Ambient background particles -->
    <div class="ambient-bg" aria-hidden="true">
        <div class="particle"></div>
        <div class="particle"></div>
        <div class="particle"></div>
        <div class="particle"></div>
        <div class="particle"></div>
        <div class="particle"></div>
        <div class="particle"></div>
        <div class="particle"></div>
    </div>

    <!-- ‚îÄ‚îÄ Header ‚îÄ‚îÄ -->
    <header class="app-header">
        <div class="header-inner">
            <div class="brand">
                <span class="brand-icon">üéµ</span>
                <h1 class="brand-title">BardBoard <span class="ampersand">&amp;</span> Dragons</h1>
                <span class="brand-icon dragon">üêâ</span>
            </div>

            <nav class="controls" aria-label="Playback controls">
                <div class="volume-group">
                    <svg class="vol-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14"></path><path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>
                    <input id="volumeSlider" type="range" min="0" max="100" step="1" value="50" aria-label="Volume">
                </div>

                <button id="pauseToggle" class="ctrl-btn ctrl-pause" onclick="handlePauseToggle()" aria-label="Pause/Resume">
                    <svg id="pauseIcon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect>
                    </svg>
                    <span>Pause</span>
                </button>

                <button id="repeatToggle" class="ctrl-btn ctrl-repeat" onclick="handleRepeatToggle()" aria-label="Toggle repeat">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M17 1l4 4-4 4"></path><path d="M3 11V9a4 4 0 014-4h14"></path>
                        <path d="M7 23l-4-4 4-4"></path><path d="M21 13v2a4 4 0 01-4 4H3"></path>
                    </svg>
                    <span>Repeat</span>
                </button>

                <button id="stopButton" class="ctrl-btn ctrl-stop" aria-label="Stop">
                    <svg viewBox="0 0 24 24" fill="currentColor"><rect x="4" y="4" width="16" height="16" rx="2"></rect></svg>
                    <span>Stop</span>
                </button>
            </nav>
        </div>

        <!-- Now-playing strip -->
        <div id="nowPlayingBar" class="now-playing-strip">
            <span class="np-pulse" aria-hidden="true"></span>
            <span class="np-label">Now Playing</span>
            <span class="np-divider">‚Ä∫</span>
            <span id="nowPlayingSong" class="np-song">Nothing playing</span>

            <!-- progress bar (hidden until a song is playing) -->
            <div class="np-progress-row" id="npProgressRow">
                <span class="np-time" id="npElapsed">0:00</span>
                <div class="np-bar-track" id="npBarTrack">
                    <div class="np-bar-fill" id="npBarFill"></div>
                    <div class="np-bar-thumb" id="npBarThumb"></div>
                </div>
                <span class="np-time" id="npDuration">0:00</span>
            </div>
        </div>
    </header>

    <!-- ‚îÄ‚îÄ Main soundboard ‚îÄ‚îÄ -->
    <main class="soundboard">
        <div id="audioButtons"></div>
    </main>

    <!-- ‚îÄ‚îÄ Footer ‚îÄ‚îÄ -->
    <footer class="app-footer">
        <span>Made with ‚ô• by <a href="https://github.com/giabb" target="_blank" rel="noopener">giabb</a></span>
    </footer>

<!-- ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Scripts ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
<script>
// -------------------------------------------------------
// Button generation
// -------------------------------------------------------
fetch('/audio-files')
    .then(r => r.json())
    .then(data => {
        const container = document.getElementById('audioButtons');
        container.innerHTML = ''; // Clear loading state if any

        // Helper to create a grid of buttons
        const createGrid = (files, animationOffset = 0) => {
            const grid = document.createElement('div');
            grid.className = 'track-grid';

            files.forEach((file, i) => {
                // Display name: removes folder path and extension
                // e.g. "Dungeon/Scary.mp3" -> "Scary"
                const displayName = file.split('/').pop().replace(/\.[^/.]+$/, '');

                const btn = document.createElement('button');
                btn.className = 'track-btn';
                // Stagger animation slightly based on index
                btn.style.animationDelay = `${(i + animationOffset) * 0.03}s`;
                btn.setAttribute('data-track', file.replace(/\.[^/.]+$/, '')); // used for now-playing matching
                btn.setAttribute('aria-label', `Play ${displayName}`);

                btn.innerHTML = `
                    <span class="track-label">${displayName}</span>
                `;

                btn.addEventListener('click', () => {
                    playAudio(file); // Passes "Folder/File.mp3" to server
                    btn.classList.add('pressed');
                    setTimeout(() => btn.classList.remove('pressed'), 200);
                });

                grid.appendChild(btn);
            });
            return grid;
        };

        let globalCount = 0;

        // Render Root Files (Uncategorized)
        if (data.root && data.root.length > 0) {
            container.appendChild(createGrid(data.root, globalCount));
            globalCount += data.root.length;
        }

        // Render Categories
        if (data.categories) {
            Object.keys(data.categories).forEach(folderName => {
                const files = data.categories[folderName];

                // Create the Header with a toggle
                const header = document.createElement('h2');
                header.className = 'category-header';
                header.innerHTML = `
                    <span>${folderName}</span>
                    <svg class="cat-chevron" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <polyline points="6 9 12 15 18 9"></polyline>
                    </svg>
                `;

                // Create a wrapper for the collapsible effect
                const wrapper = document.createElement('div');
                wrapper.className = 'category-wrapper'; // Default state: Open

                const inner = document.createElement('div');
                inner.className = 'category-inner';

                // Put the grid inside the inner wrapper
                inner.appendChild(createGrid(files, globalCount));
                wrapper.appendChild(inner);

                // Add Click Event to Toggle
                header.addEventListener('click', () => {
                    // Toggle the 'collapsed' class on both header (for arrow rotation) and wrapper (for height)
                    header.classList.toggle('collapsed');
                    wrapper.classList.toggle('collapsed');
                });

                // Append everything to the main container
                container.appendChild(header);
                container.appendChild(wrapper);

                globalCount += files.length;
            });
        }
    });

let isPaused = false;

function handlePauseToggle() {
    fetch('/toggle-pause', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ channelId: window.ENV.channelId })
    })
    .then(r => r.json())
    .then(data => {
        updatePauseUI(data.paused);
    });
}

function updatePauseUI(paused) {
    isPaused = paused;
    const btn = document.getElementById('pauseToggle');
    const icon = document.getElementById('pauseIcon');
    const label = btn.querySelector('span');

    if (isPaused) {
        btn.classList.add('paused');
        label.textContent = 'Resume';
        // Switch to Play Icon
        icon.innerHTML = '<polygon points="5 3 19 12 5 21 5 3"></polygon>';
    } else {
        btn.classList.remove('paused');
        label.textContent = 'Pause';
        // Switch back to Pause Icon
        icon.innerHTML = '<rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect>';
        // Reset poll time when resuming so interpolation continues correctly
        npPollTime = performance.now();
    }
}

// -------------------------------------------------------
// API helpers
// -------------------------------------------------------
function playAudio(fileName) {
    fetch('/play-audio', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ fileName, channelId: window.ENV.channelId })
    });
}

document.getElementById('stopButton').addEventListener('click', () => {
    fetch('/stop-audio', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ channelId: window.ENV.channelId })
    });
    updateNowPlaying();
});

let isRepeatEnabled = false;
function handleRepeatToggle() {
    isRepeatEnabled = !isRepeatEnabled;
    document.getElementById('repeatToggle').classList.toggle('active', isRepeatEnabled);

    fetch('/toggle-repeat', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ channelId: window.ENV.channelId })
    }).catch(err => console.error('toggle-repeat error:', err));
}

document.getElementById('volumeSlider').addEventListener('input', function () {
    fetch('/set-volume', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ channelId: window.ENV.channelId, volume: this.value / 100 })
    }).catch(err => console.error('set-volume error:', err));
});

// -------------------------------------------------------
// Now-Playing polling, progress bar, seek
// -------------------------------------------------------

/** latest server payload ‚Äî kept in module scope so the local ticker can read it */
let npState = { song: null, elapsed: 0, duration: 0, paused: false };
/** timestamp (performance.now) of the last successful poll */
let npPollTime = 0;

/**
 * Formats seconds ‚Üí "M:SS"
 */
function formatTime(sec) {
    sec = Math.max(0, Math.floor(sec));
    const m = Math.floor(sec / 60);
    const s = sec % 60;
    return `${m}:${s.toString().padStart(2, '0')}`;
}

/**
 * Renders the progress bar and time labels from the current npState,
 * optionally interpolating elapsed forward by `dt` seconds since last poll.
 */
function renderProgress(dt) {
    const elapsed  = Math.min(npState.elapsed + (dt || 0), npState.duration);
    const duration = npState.duration;
    const pct      = duration > 0 ? (elapsed / duration) * 100 : 0;

    document.getElementById('npElapsed').textContent  = formatTime(elapsed);
    document.getElementById('npDuration').textContent = formatTime(duration);
    document.getElementById('npBarFill').style.width  = pct + '%';
    document.getElementById('npBarThumb').style.left  = pct + '%';
}

/**
 * Polls /now-playing, updates song label + button highlights,
 * shows/hides the progress row, and anchors the local interpolation ticker.
 */
function updateNowPlaying() {
    if (!window.ENV || !window.ENV.channelId) return;

    fetch('/now-playing?channelId=' + encodeURIComponent(window.ENV.channelId))
        .then(r => r.json())
        .then(data => {
            const songEl    = document.getElementById('nowPlayingSong');
            const barEl     = document.getElementById('nowPlayingBar');
            const progRow   = document.getElementById('npProgressRow');

            document.querySelectorAll('.track-btn').forEach(b => b.classList.remove('playing'));

            npState   = data;
            npPollTime = performance.now();
            isPaused  = data.paused || false;

            if (data.song) {
                songEl.textContent = data.song;
                barEl.classList.add('has-song');
                progRow.classList.add('visible');

                document.querySelectorAll('.track-btn').forEach(b => {
                    if (b.dataset.track === data.song) b.classList.add('playing');
                });

                renderProgress(0);
            } else {
                songEl.textContent = 'Nothing playing';
                barEl.classList.remove('has-song');
                progRow.classList.remove('visible');
                npState = { song: null, elapsed: 0, duration: 0 };
            }
        })
        .catch(err => console.error('now-playing poll error:', err));
}

/**
 * Runs every 250 ms: interpolates elapsed forward from the last polled
 * snapshot so the bar moves smoothly between 1-second server polls.
 * Only updates when not paused.
 */
setInterval(() => {
    if (!npState.song || isPaused) return;
    const dt = (performance.now() - npPollTime) / 1000;
    renderProgress(dt);
}, 250);

// -------------------------------------------------------
// Seek interaction (click / drag on the progress bar)
// -------------------------------------------------------
(function setupSeek() {
    const track = document.getElementById('npBarTrack');
    let dragging = false;

    function seekFromEvent(e) {
        const rect  = track.getBoundingClientRect();
        const ratio = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
        const target = ratio * npState.duration;

        // optimistic local update so the bar jumps instantly
        npState.elapsed = target;
        npPollTime      = performance.now();
        renderProgress(0);

        // tell the server
        fetch('/seek', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ channelId: window.ENV.channelId, offsetSecs: target })
        }).catch(err => console.error('seek error:', err));
    }

    track.addEventListener('mousedown', e => {
        if (!npState.song) return;
        dragging = true;
        track.classList.add('dragging');
        seekFromEvent(e);
    });
    window.addEventListener('mousemove', e => {
        if (!dragging) return;
        seekFromEvent(e);
    });
    window.addEventListener('mouseup', () => {
        dragging = false;
        track.classList.remove('dragging');
    });

    // touch support
    track.addEventListener('touchstart', e => {
        if (!npState.song) return;
        dragging = true;
        track.classList.add('dragging');
        seekFromEvent(e.touches[0]);
        e.preventDefault();
    }, { passive: false });
    window.addEventListener('touchmove', e => {
        if (!dragging) return;
        seekFromEvent(e.touches[0]);
        e.preventDefault();
    }, { passive: false });
    window.addEventListener('touchend', () => {
        dragging = false;
        track.classList.remove('dragging');
    });
})();

function syncRepeatState() {
    if (!window.ENV || !window.ENV.channelId) return;
    fetch('/repeat-status?channelId=' + encodeURIComponent(window.ENV.channelId))
        .then(r => r.json())
        .then(data => {
            isRepeatEnabled = !!data.repeatEnabled;
            document.getElementById('repeatToggle').classList.toggle('active', isRepeatEnabled);
        })
        .catch(err => console.error('repeat-status error:', err));
}

setInterval(updateNowPlaying, 1000);
setTimeout(() => { updateNowPlaying(); syncRepeatState(); }, 800);
</script>
</body>
</html>